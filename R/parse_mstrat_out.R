#' Parse Output Files from \code{MStrat}
#'
#' Prepare raw output files generated by \code{MStrat}
#' \insertCite{schoen_Conservation_1993a,gouesnard_MSTRAT_2001,gouesnard_MStrat_2002}{avial}.
#'
#' @param data.file The path to the \code{.dat} input file used for generating
#'   the output files from \code{MStrat}.
#' @param genotype Name of column/variable with the genotype names as a
#'   character string.
#' @param variable.file The path to the \code{.var} input file used for
#'   generating the output files from \code{MStrat}.
#' @param kernel.file The path to the \code{.ker} input file used for generating
#'   the output files from \code{MStrat}.
#' @param redundance.output The path to the redundance output file generated by
#'   \code{MStrat}.
#' @param core.output The path to the core output file generated by
#'   \code{MStrat}.
#'
#' @return A list with the following components: \item{\code{MStrat Core
#'   Output}}{The raw output of core sets constructed by \code{MStrat}.}
#'   \item{\code{MStrat Core Optimised}}{The optimised core set output from
#'   \code{MStrat}.} \item{\code{MStrat Redundance Output}}{The raw output of
#'   Redundance estimation by \code{MStrat}} \item{\code{MStrat Redundance
#'   Plot}}{A list of plots of Redundance estimation.}
#'
#' @import ggplot2
#' @importFrom dplyr all_of summarise
#' @importFrom tidyr pivot_longer
#' @importFrom utils read.delim
#' @export
#'
#' @references
#'
#' \insertAllCited{}
#'
#' @seealso \code{\link[avial]{prep_mstrat_input}}
#'
#' @examplesIf interactive()
#'
#' parse_mstrat_out(data.file = "MStrat_input_data.dat",
#'                  genotype = "Accession",
#'                  variable.file = "MStrat_input_variable.var",
#'                  kernel.file = "MStrat_input_kernel.ker",
#'                  redundance.output = "MStrat - Redundance.out",
#'                  core.output = "MStrat - Core.out")
#'
parse_mstrat_out <- function(data.file,
                             genotype = NULL,
                             variable.file,
                             kernel.file,
                             redundance.output = NULL,
                             core.output = NULL) {
  # Checks ----

  # Load the MStrat input files ----

  data_out <- read.delim(file = data.file, header = FALSE,
                         sep = " ", quote = "",
                         na.strings = 9999, stringsAsFactors = FALSE)

  var_out <- read.delim(file = variable.file, header = FALSE,
                        sep = " ", quote = "",
                        stringsAsFactors = FALSE, skip = 2)
  colnames(data_out) <- c("code", "count", var_out$V1)

  if (!(is.null(kernel.file))) {
    ker_out <- read.delim(file = kernel.file, header = FALSE,
                          sep = " ", quote = "",
                          stringsAsFactors = FALSE)
    colnames(ker_out) <- c("code", "presence")
  }

  core_parsed <- NULL
  core_out <- NULL
  red_parsed <- NULL
  outg <- NULL

  # Load and parse the MStrat core output files ----

  if (!(is.null(core.output))) {
    core_parsed <- read.delim(file = core.output, header = TRUE,
                              sep = "", quote = "",
                              skip = 3, stringsAsFactors = FALSE,
                              strip.white = TRUE)

    # table(core_parsed[, 4])

    # Subset the core
    ind_max <- max(core_parsed[, 4])

    core_out <- core_parsed[core_parsed[, 4] == ind_max, ]

    # Check if kernel accessions are in core
    if (!(is.null(kernel.file))) {
      ker_ind <- ker_out[ker_out$presence == 1, ]$code %in% core_out$Noaccess
      if (!all(ker_ind)) {
        warning("Accessions specified in kernel file are missing in core output.")
      }
    }

    if (!(is.null(genotype))) {
      core_out <-  merge.data.frame(core_out, data_out[, c("code", genotype)],
                                    by.x = "Noaccess", by.y = "code",
                                    all.x = TRUE)
      core_out <- unique(core_out)
    }
  }

  # Load and parse the MStrat Redundance output files ----

  if (!(is.null(redundance.output))) {

    red_parsed <- read.delim(file = redundance.output, header = TRUE,
                             sep = "", quote = "",
                             skip = 2, stringsAsFactors = FALSE,
                             strip.white = TRUE)

    red_parsed_long <- red_parsed

    red_parsed_long$method <- as.factor(red_parsed_long$method)
    levels(red_parsed_long$method) <- c("M Method", "Random")

    red_parsed_long <-
      tidyr::pivot_longer(data = red_parsed_long,
                          cols = c("scoreactiv", "scoretarget"),
                          names_to = "Type", values_to = "Value")

    red_parsed_long$Type <- as.factor(red_parsed_long$Type)
    levels(red_parsed_long$Type) <- c("Active", "Target")

    red_parsed_long_avg <-
      summarise(.data = red_parsed_long,
                .by = all_of(c("method", "coresize", "Type")),
                mean = mean(Value, na.rm = TRUE))

    nbreaks <- floor(max(red_parsed$coresize) / 100) # at 100 interval

    redg1 <-
      ggplot(data = red_parsed_long_avg,
             aes(x = coresize, y = mean,
                 group = method, colour = method)) +
      geom_point(alpha = 0.8) +
      scale_colour_manual(values = c("#2166AC", "#B2182B")) +
      scale_x_continuous(n.breaks = nbreaks) +
      xlab("Size") +
      ylab("Score") +
      labs(colour = NULL) +
      facet_wrap(~ Type) +
      labs(title = "Average") +
      theme_bw()

    redg2 <-
      ggplot(data = red_parsed_long,
             aes(x = coresize, y = Value,
                 group = method, colour = method)) +
      geom_point(alpha = 0.8) +
      scale_colour_manual(values = c("#2166AC", "#B2182B")) +
      scale_x_continuous(n.breaks = nbreaks) +
      xlab("Size") +
      ylab("Score") +
      labs(colour = NULL) +
      facet_wrap(~ Type) +
      labs(title = "Cloud") +
      theme_bw()

    # outg <-   redg1 / redg2 + plot_layout(guides = "collect")

  }

  out <- list(`MStrat Core Output` = core_parsed,
              `MStrat Core Optimised` = core_out,
              `MStrat Redundance Output` = red_parsed,
              `MStrat Redundance Plot` = list(Active = redg1, Target = redg2))

  return(out)

}
